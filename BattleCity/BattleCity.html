<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Battle City - Gr√°ficos Jogador Corrigidos</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Estilos Gerais */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body {
            font-family: 'Press Start 2P', Courier, monospace; background-color: #222; color: white;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            touch-action: manipulation;
        }
        canvas {
            border: 3px solid #eee; display: block; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            background-image: url('https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/bgremix.png');
            background-size: cover; background-position: center; background-repeat: no-repeat;
            z-index: 1; position: relative;
            width: 100%; height: 100%; /* Ocupa o container */
             image-rendering: pixelated; image-rendering: crisp-edges;
        }

        /* --- Tela Inicial --- */
        #start-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; width: 100%; height: 100%; background-color: #111; z-index: 50; position: absolute; top: 0; left: 0; }
        #start-screen h1 { font-size: 3em; color: #FFD700; text-shadow: 3px 3px 0px #c00, 5px 5px 5px rgba(0,0,0,0.5); margin-bottom: 20px; }
        #start-screen p { font-size: 0.9em; color: #ccc; margin-bottom: 30px; max-width: 90%; padding: 0 10px; }
        #start-button { font-family: 'Press Start 2P', Courier, monospace; font-size: 1.3em; padding: 12px 25px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; text-shadow: 1px 1px 2px black; transition: background-color 0.3s ease; box-shadow: 0 5px #367c39; }
        #start-button:hover { background-color: #45a049; }
        #start-button:active { box-shadow: 0 2px #367c39; transform: translateY(3px); }
        #footer { position: absolute; bottom: 10px; font-size: 0.6em; color: #888; text-align: center; width: 100%;}
        #footer s { color: #aaa; }

        /* --- Container do Jogo --- */
        #game-container {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            position: relative; width: 95vw; height: 95vh;
            max-width: 600px; max-height: calc(600px * (16 / 9)); aspect-ratio: 9 / 16;
        }

        /* --- UI do Jogo (HUD Superior) --- */
        #game-ui {
            position: absolute; top: 5px; left: 50%; transform: translateX(-50%);
            width: 98%; box-sizing: border-box;
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: none; color: #eee; font-size: clamp(0.6em, 2vw, 0.8em);
            text-shadow: 1px 1px 2px black; padding: 8px 12px;
            z-index: 10; background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
        }
        .hud-item { display: flex; flex-direction: column; align-items: flex-start; }
        .hud-item label { margin-bottom: 4px; opacity: 0.8; }
        .hud-item span { font-weight: bold; min-height: 1.2em; }
        #hp-container { align-items: flex-start; }
        #hp-bar { width: clamp(50px, 15vw, 70px); height: 6px; background-color: #444; border: 1px solid #888; border-radius: 2px; overflow: hidden; margin-top: 2px; }
        #hp-bar-inner { height: 100%; width: 100%; background-color: #4CAF50; transition: width 0.3s ease, background-color 0.3s ease; }
        #abates-container { align-items: center; flex-grow: 1; text-align: center; }
        #pontos-container { align-items: flex-end; text-align: right; }

        /* --- Controles Mobile --- */
        #mobile-controls { display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 25vh; padding: 10px; box-sizing: border-box; justify-content: space-between; align-items: center; z-index: 20; pointer-events: none; }
        .controls-hidden { display: none !important; }
        #analog-stick-area { width: clamp(120px, 35vw, 160px); height: clamp(120px, 35vw, 160px); border-radius: 50%; background-color: rgba(80, 80, 80, 0.2); position: relative; pointer-events: auto; margin-left: 15px; border: none; }
        #analog-handle { width: clamp(40px, 12vw, 50px); height: clamp(40px, 12vw, 50px); border-radius: 50%; background-color: rgba(150, 150, 150, 0.3); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: transform 0.05s linear; }
        #action-buttons { display: flex; flex-direction: column-reverse; align-items: flex-end; gap: 10px; position: fixed; bottom: 15px; right: 15px; pointer-events: auto; }
        .mobile-button { background-color: rgba(80, 80, 80, 0.2); border: none; color: rgba(255, 255, 255, 0.5); border-radius: 50%; width: clamp(65px, 17vw, 80px); height: clamp(65px, 17vw, 80px); display: flex; justify-content: center; align-items: center; font-size: clamp(1.8em, 6vw, 2.4em); cursor: pointer; user-select: none; pointer-events: auto; transition: background-color 0.1s ease; }
        .mobile-button:active { background-color: rgba(120, 120, 120, 0.3); }
        #pause-button-mobile { display: none; width: clamp(50px, 13vw, 60px); height: clamp(50px, 13vw, 60px); font-size: clamp(1.1em, 3.5vw, 1.3em); z-index: 25; }
        #pause-button-mobile span { display: block; line-height: 1; }

        /* --- Menu de Pausa --- */
        #pause-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(1.2em, 4vw, 1.5em); text-align: center; padding: 20px 30px; background-color: rgba(0, 0, 0, 0.85); border-radius: 10px; display: none; text-shadow: 2px 2px 4px black; z-index: 30; color: #eee; flex-direction: column; gap: 10px; }
        #pause-menu h2 { font-size: 1.2em; margin: 0 0 10px 0; color: #FFD700; }
        .pause-button { font-family: 'Press Start 2P', Courier, monospace; font-size: 0.8em; padding: 8px 20px; background-color: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer; text-shadow: 1px 1px 1px black; transition: background-color 0.3s ease; box-shadow: 0 4px #0056b3; pointer-events: auto; width: 100%; }
        .pause-button:hover { background-color: #0056b3; }
        .pause-button:active { box-shadow: 0 2px #0056b3; transform: translateY(2px); }

        /* --- Mensagens Overlay (Game Over, Win) --- */
        .message-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(1.5em, 5vw, 1.8em); text-align: center; padding: 20px 30px; background-color: rgba(0, 0, 0, 0.8); border-radius: 10px; display: none; text-shadow: 2px 2px 4px black; z-index: 25; }
        #game-over, #win-message { color: #eee; }
        #game-over span { color: #ff4d4d; display: block; margin-bottom: 15px; font-size: 1.5em; }
        #win-message span { color: #4dff4d; display: block; margin-bottom: 15px; font-size: 1.3em; }
        .overlay-button { font-family: 'Press Start 2P', Courier, monospace; font-size: 0.7em; padding: 8px 15px; background-color: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer; text-shadow: 1px 1px 1px black; transition: background-color 0.3s ease; margin-top: 10px; box-shadow: 0 4px #0056b3; pointer-events: auto; }
        .overlay-button:hover { background-color: #0056b3; }
        .overlay-button:active { box-shadow: 0 2px #0056b3; transform: translateY(2px); }

    </style>
</head>
<body>

    <div id="start-screen">
        <h1>Battle City</h1>
        <p>Sobreviva e destrua o m√°ximo de tanques inimigos!</p>
        <button id="start-button">Novo Jogo</button>
        <div id="footer">Um jogo 100% feito <s>pelo Wesley</s> por IA - vulgo Gemini</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="game-ui">
            <div id="hp-container" class="hud-item">
                <label id="hp-label">Vida</label>
                <div id="hp-bar"><div id="hp-bar-inner"></div></div>
            </div>
            <div id="lives-container" class="hud-item">
                <label>Chances</label>
                <span id="lives-count">0/0</span>
            </div>
            <div id="abates-container" class="hud-item">
                <label>Abates</label>
                <span id="destroyed-count">0/0</span>
            </div>
            <div id="pontos-container" class="hud-item">
                <label>Pontos</label>
                <span id="score">0</span>
            </div>
        </div>
         <div id="mobile-controls">
             <div id="analog-stick-area">
                 <div id="analog-handle"></div>
             </div>
             <div id="action-buttons">
                 <button id="shoot-button" class="mobile-button">üí•</button>
                 <button id="pause-button-mobile" class="mobile-button"><span>‚ùö‚ùö</span></button>
             </div>
         </div>

         <div id="pause-menu">
             <h2>Pausado</h2>
             <button id="resume-button" class="pause-button">Continuar</button>
             <button id="restart-pause-button" class="pause-button">Reiniciar</button>
             <button id="exit-pause-button" class="pause-button">Sair</button>
         </div>

        <div id="game-over" class="message-overlay">
            <span>Game Over!</span>
            <button id="restart-button" class="overlay-button">Reiniciar</button>
        </div>
        <div id="win-message" class="message-overlay">
             <span>Parab√©ns, fase conclu√≠da!</span>
            <button id="next-phase-button" class="overlay-button">Pr√≥xima Fase</button>
        </div>
    </div>

    <script>
        // --- Elementos do DOM ---
        const startScreen = document.getElementById("start-screen");
        const gameContainer = document.getElementById("game-container");
        const startButton = document.getElementById("start-button");
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const hpBarInner = document.getElementById("hp-bar-inner");
        const livesCountDisplay = document.getElementById("lives-count");
        const scoreDisplay = document.getElementById("score");
        const destroyedCountDisplay = document.getElementById("destroyed-count");
        const gameOverMessage = document.getElementById("game-over");
        const winMessage = document.getElementById("win-message");
        const restartButton = document.getElementById("restart-button");
        const nextPhaseButton = document.getElementById("next-phase-button");
        const mobileControls = document.getElementById("mobile-controls");
        const analogStickArea = document.getElementById("analog-stick-area");
        const analogHandle = document.getElementById("analog-handle");
        const actionButtons = document.getElementById("action-buttons");
        const shootButton = document.getElementById("shoot-button");
        const pauseButtonMobile = document.getElementById("pause-button-mobile");
        // toggleControlsButton removido
        const pauseMenu = document.getElementById("pause-menu");
        const resumeButton = document.getElementById("resume-button");
        const restartPauseButton = document.getElementById("restart-pause-button");
        const exitPauseButton = document.getElementById("exit-pause-button");

        // --- Configura√ß√µes e Constantes ---
        const PLAYER_SPEED = 2.5;
        const ENEMY_SPEED = 1.2;
        const BULLET_SPEED_PLAYER = 5;
        const BULLET_SPEED_ENEMY = 3.5;
        const PLAYER_TANK_SIZE = 120; // Tamanho do jogador aumentado
        const ENEMY_TANK_SIZE = 60;   // Tamanho do inimigo mantido
        const BULLET_WIDTH = 10; // Ajustado para novo tamanho m√©dio
        const BULLET_HEIGHT = 18; // Ajustado
        const ENEMY_SHOOT_CHANCE = 0.015;
        const ENEMY_CHANGE_DIRECTION_CHANCE = 0.02;
        const MAX_ENEMIES_ON_SCREEN = 3;
        const MAX_LIVES = 3;
        const MAX_HP = 3;
        const POINTS_PER_KILL = 10;
        const POINTS_LOST_ON_HIT = -5;
        const POINTS_LOST_ON_DEATH = -25;
        const KILLS_PER_PHASE_BASE = 5;
        const INVULNERABILITY_DURATION_HIT = 1500;
        const INVULNERABILITY_DURATION_SPAWN = 3000;
        const RESPAWN_DELAY = 1000;
        const DIAGONAL_SPEED_MULTIPLIER = 1 / Math.sqrt(2);
        const ANALOG_DEAD_ZONE = 0.15;

        // --- Vari√°veis de Estado do Jogo ---
        let gameState = 'start';
        let score = 0;
        let playerLives = 0;
        let playerHP = 0;
        let currentPhase = 1;
        let killsThisPhase = 0;
        let killsNeededThisPhase = 0;
        let enemiesSpawnedThisPhase = 0;
        let animationFrameId = null;
        let isTouchDevice = false;
        const keysPressed = { up: false, down: false, left: false, right: false };
        let analogActive = false;
        let analogStartX = 0, analogStartY = 0, analogCenterX = 0, analogCenterY = 0, analogRadius = 0;

        let playerTank = null;
        const bullets = [];
        const enemies = [];
        const enemyBullets = [];

        // --- Pr√©-carregamento das Imagens do Jogador ---
        const playerImages = {};
        const playerImageSources = { // URLs corrigidos e mapeamento Cima/Baixo corrigido
            'up':         'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersFrent.png', // Cima
            'down':       'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersTras.png',   // Baixo
            'left':       'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersEsq.png',
            'right':      'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersDir.png',
            'up-left':    'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersCimEsq.png',
            'up-right':   'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersCimDir.png',
            'down-left':  'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersBaiEsq.png',
            'down-right': 'https://raw.githubusercontent.com/Wes1994/wes1994.github.io/main/BattleCity/Graficos%20Personagem/PersBaiDir.png'
        };
        let imagesLoaded = 0;
        const totalImages = Object.keys(playerImageSources).length;

        function preloadImages(callback) {
            imagesLoaded = 0;
            for (const direction in playerImageSources) {
                playerImages[direction] = new Image();
                playerImages[direction].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        if (callback) callback();
                    }
                };
                playerImages[direction].onerror = () => {
                    console.error(`Erro ao carregar imagem: ${playerImageSources[direction]}`);
                    imagesLoaded++; // Conta erro para n√£o travar
                    if (imagesLoaded === totalImages) {
                        if (callback) callback();
                    }
                };
                playerImages[direction].src = playerImageSources[direction];
            }
        }


        // --- Sons (Simulados) ---
        const playSound = (type) => { /* Silenciado */ };
        const shootSound = { play: () => playSound('Tiro') };
        const explosionSound = { play: () => playSound('Explos√£o') };
        const playerHitSound = { play: () => playSound('Jogador Atingido') };
        const playerDeathSound = { play: () => playSound('Jogador Morreu') };
        const phaseCompleteSound = { play: () => playSound('Fase Completa') };
        const gameOverSound = { play: () => playSound('Game Over') };

        // --- Fun√ß√µes do Jogador ---
        function createPlayer(isRespawn = false) {
            const startX = canvas.width / 2 - PLAYER_TANK_SIZE / 2; // Usa tamanho do jogador
            const startY = canvas.height - PLAYER_TANK_SIZE - 40; // Usa tamanho do jogador
            const newPlayer = {
                x: startX, y: startY,
                width: PLAYER_TANK_SIZE, height: PLAYER_TANK_SIZE, // Tamanho do jogador
                dx: 0, dy: 0, speed: PLAYER_SPEED, direction: 'up',
                invulnerable: true, invulnerabilityEndTime: Date.now() + INVULNERABILITY_DURATION_SPAWN, visible: true
            };
            if (!isRespawn) { playerLives = MAX_LIVES; }
            playerHP = MAX_HP; updateHpBar(); updateInfoDisplays(); return newPlayer;
        }
        function updatePlayerInvulnerability() { /* ... (sem mudan√ßas) ... */
             if (playerTank && playerTank.invulnerable) { if (Date.now() >= playerTank.invulnerabilityEndTime) { playerTank.invulnerable = false; playerTank.visible = true; } else { playerTank.visible = (Date.now() % 400 < 200); } }
        }
        function updatePlayerDirectionAndMovement() { /* ... (sem mudan√ßas) ... */
            if (!playerTank || analogActive) return; let targetDx = 0; let targetDy = 0; if (keysPressed.up) targetDy = -1; if (keysPressed.down) targetDy = 1; if (keysPressed.left) targetDx = -1; if (keysPressed.right) targetDx = 1; if (keysPressed.up && keysPressed.down) targetDy = 0; if (keysPressed.left && keysPressed.right) targetDx = 0; if (targetDx === 0 && targetDy === -1) playerTank.direction = 'up'; else if (targetDx === 1 && targetDy === -1) playerTank.direction = 'up-right'; else if (targetDx === 1 && targetDy === 0) playerTank.direction = 'right'; else if (targetDx === 1 && targetDy === 1) playerTank.direction = 'down-right'; else if (targetDx === 0 && targetDy === 1) playerTank.direction = 'down'; else if (targetDx === -1 && targetDy === 1) playerTank.direction = 'down-left'; else if (targetDx === -1 && targetDy === 0) playerTank.direction = 'left'; else if (targetDx === -1 && targetDy === -1) playerTank.direction = 'up-left'; playerTank.dx = targetDx; playerTank.dy = targetDy;
        }
        function movePlayer() { /* ... (sem mudan√ßas) ... */
            if (!playerTank || gameState !== 'playing') return; let moveX = playerTank.dx; let moveY = playerTank.dy; let currentSpeed = playerTank.speed; if (moveX !== 0 && moveY !== 0) { currentSpeed *= DIAGONAL_SPEED_MULTIPLIER; } let nextX = playerTank.x + moveX * currentSpeed; let nextY = playerTank.y + moveY * currentSpeed; if (nextX < 0) nextX = 0; if (nextX > canvas.width - playerTank.width) nextX = canvas.width - playerTank.width; if (nextY < 0) nextY = 0; if (nextY > canvas.height - playerTank.height) nextY = canvas.height - playerTank.height; if (!playerTank.invulnerable) { const playerRect = { x: nextX, y: nextY, width: playerTank.width, height: playerTank.height }; for (const enemy of enemies) { if (isColliding(playerRect, enemy)) { if (moveX !== 0) nextX = playerTank.x; if (moveY !== 0) nextY = playerTank.y; break; } } } playerTank.x = nextX; playerTank.y = nextY;
        }
        function shootPlayerBullet() { /* ... (sem mudan√ßas) ... */
            if (!playerTank || gameState !== 'playing' || playerTank.invulnerable) return; const bullet = createBullet(playerTank, BULLET_SPEED_PLAYER, playerTank.direction, 'player'); bullets.push(bullet); shootSound.play();
        }
        function playerHit() { /* ... (sem mudan√ßas) ... */
            if (gameState !== 'playing' || (playerTank && playerTank.invulnerable)) return; playerHitSound.play(); playerHP--; updateScore(POINTS_LOST_ON_HIT); updateHpBar(); if (playerHP <= 0) { playerDeathSound.play(); playerLives--; updateScore(POINTS_LOST_ON_DEATH); updateInfoDisplays(); if (playerLives <= 0) { gameOverSequence(); } else { playerTank = null; setTimeout(respawnPlayer, RESPAWN_DELAY); } } else { playerTank.invulnerable = true; playerTank.invulnerabilityEndTime = Date.now() + INVULNERABILITY_DURATION_HIT; playerTank.visible = true; }
        }
        function respawnPlayer() { /* ... (sem mudan√ßas) ... */
             if (gameState === 'playing' || gameState === 'paused') { playerTank = createPlayer(true); if (gameState === 'paused') { draw(); } }
        }

        // --- Fun√ß√µes dos Inimigos ---
        function createEnemy() { // Usa ENEMY_TANK_SIZE
             if (enemies.length >= MAX_ENEMIES_ON_SCREEN || enemiesSpawnedThisPhase >= killsNeededThisPhase || gameState === 'start' || gameState === 'gameOver' || gameState === 'phaseComplete') { return; } let x, y, attempts = 0; const maxAttempts = 50;
             do { x = Math.random() * (canvas.width - ENEMY_TANK_SIZE); y = Math.random() * (canvas.height / 2 - ENEMY_TANK_SIZE); attempts++; } while (isOverlapping(x, y, ENEMY_TANK_SIZE, ENEMY_TANK_SIZE, enemies.concat(playerTank ? [playerTank] : [])) && attempts < maxAttempts);
             if (attempts >= maxAttempts) { return; } const initialDirection = ['up', 'down', 'left', 'right', 'up-left', 'up-right', 'down-left', 'down-right'][Math.floor(Math.random() * 8)];
             const enemy = { id: Date.now() + Math.random(), x: x, y: y,
                            width: ENEMY_TANK_SIZE, height: ENEMY_TANK_SIZE, // Tamanho do inimigo
                            dx: 0, dy: 0, speed: ENEMY_SPEED, direction: initialDirection, color: "#B22222", trackColor: "#8B0000", gunColor: "#696969", shootCooldown: Math.random() * 150 + 100 };
             setEnemyDirection(enemy, initialDirection); enemies.push(enemy); enemiesSpawnedThisPhase++;
        }
        function moveEnemies() { /* ... (sem mudan√ßas) ... */
            if (gameState !== 'playing') return; enemies.forEach((enemy, index) => { enemy.shootCooldown = Math.max(0, enemy.shootCooldown - 1); let moveX = enemy.dx; let moveY = enemy.dy; let currentSpeed = enemy.speed; if (moveX !== 0 && moveY !== 0) { currentSpeed *= DIAGONAL_SPEED_MULTIPLIER; } let nextEnemyX = enemy.x + moveX * currentSpeed; let nextEnemyY = enemy.y + moveY * currentSpeed; let collidedWithBorder = false; if (nextEnemyX <= 0 || nextEnemyX >= canvas.width - enemy.width) { enemy.dx *= -1; nextEnemyX = enemy.x; collidedWithBorder = true; } if (nextEnemyY <= 0 || nextEnemyY >= canvas.height - enemy.height) { enemy.dy *= -1; nextEnemyY = enemy.y; collidedWithBorder = true; } let collidedWithOther = false; const enemyRect = { x: nextEnemyX, y: nextEnemyY, width: enemy.width, height: enemy.height }; const collisionTargets = enemies.concat( (playerTank && !playerTank.invulnerable) ? [playerTank] : [] ); for (let k = 0; k < collisionTargets.length; k++) { const otherTank = collisionTargets[k]; if (enemy === otherTank) continue; if (isColliding(enemyRect, otherTank)) { collidedWithOther = true; if (moveX !== 0) { enemy.dx *= -1; nextEnemyX = enemy.x; } if (moveY !== 0) { enemy.dy *= -1; nextEnemyY = enemy.y; } setEnemyDirection(enemy, getRandomDifferentDirection(enemy.direction, true)); break; } } enemy.x = nextEnemyX; enemy.y = nextEnemyY; if (collidedWithBorder || collidedWithOther || Math.random() < ENEMY_CHANGE_DIRECTION_CHANCE) { setEnemyDirection(enemy, getRandomDifferentDirection(enemy.direction, true)); } if (enemy.shootCooldown <= 0 && Math.random() < ENEMY_SHOOT_CHANCE) { shootEnemyBullet(enemy); enemy.shootCooldown = Math.random() * 200 + 150; } });
        }
        function getRandomDifferentDirection(currentDirection, allowDiagonal = false) { /* ... (sem mudan√ßas) ... */
             const directions = allowDiagonal ? ['up', 'down', 'left', 'right', 'up-left', 'up-right', 'down-left', 'down-right'] : ['up', 'down', 'left', 'right']; let newDirection; do { newDirection = directions[Math.floor(Math.random() * directions.length)]; } while (newDirection === currentDirection); return newDirection;
        }
        function setEnemyDirection(enemy, direction) { /* ... (sem mudan√ßas) ... */
             if (!enemy) return; enemy.direction = direction; enemy.dx = 0; enemy.dy = 0; if (direction.includes('up')) enemy.dy = -1; if (direction.includes('down')) enemy.dy = 1; if (direction.includes('left')) enemy.dx = -1; if (direction.includes('right')) enemy.dx = 1;
        }
        function shootEnemyBullet(enemy) { /* ... (sem mudan√ßas) ... */
             if (gameState !== 'playing') return; const bullet = createBullet(enemy, BULLET_SPEED_ENEMY, enemy.direction, 'enemy'); enemyBullets.push(bullet);
        }

        // --- Fun√ß√µes das Balas ---
        function createBullet(tank, speed, direction, owner) { // Ajusta posi√ß√£o inicial da bala
            const currentBulletWidth = BULLET_WIDTH; const currentBulletHeight = BULLET_HEIGHT;
            // Posi√ß√£o inicial no centro do tanque
            let bulletX = tank.x + tank.width / 2 - currentBulletWidth / 2;
            let bulletY = tank.y + tank.height / 2 - currentBulletHeight / 2;
            let dx = 0, dy = 0;
            const offsetMultiplier = 0.6; // Qu√£o longe do centro a bala aparece

            switch (direction) {
                case 'up': dy = -speed; bulletY = tank.y - currentBulletHeight; break;
                case 'down': dy = speed; bulletY = tank.y + tank.height; break;
                case 'left': dx = -speed; bulletX = tank.x - currentBulletWidth; break;
                case 'right': dx = speed; bulletX = tank.x + tank.width; break;
                case 'up-left':
                    dx = -speed * DIAGONAL_SPEED_MULTIPLIER; dy = -speed * DIAGONAL_SPEED_MULTIPLIER;
                    bulletX = tank.x + tank.width * (0.5 - offsetMultiplier / 2) - currentBulletWidth / 2;
                    bulletY = tank.y + tank.height * (0.5 - offsetMultiplier / 2) - currentBulletHeight / 2;
                    break;
                case 'up-right':
                    dx = speed * DIAGONAL_SPEED_MULTIPLIER; dy = -speed * DIAGONAL_SPEED_MULTIPLIER;
                    bulletX = tank.x + tank.width * (0.5 + offsetMultiplier / 2) - currentBulletWidth / 2;
                    bulletY = tank.y + tank.height * (0.5 - offsetMultiplier / 2) - currentBulletHeight / 2;
                    break;
                case 'down-left':
                    dx = -speed * DIAGONAL_SPEED_MULTIPLIER; dy = speed * DIAGONAL_SPEED_MULTIPLIER;
                    bulletX = tank.x + tank.width * (0.5 - offsetMultiplier / 2) - currentBulletWidth / 2;
                    bulletY = tank.y + tank.height * (0.5 + offsetMultiplier / 2) - currentBulletHeight / 2;
                    break;
                case 'down-right':
                    dx = speed * DIAGONAL_SPEED_MULTIPLIER; dy = speed * DIAGONAL_SPEED_MULTIPLIER;
                    bulletX = tank.x + tank.width * (0.5 + offsetMultiplier / 2) - currentBulletWidth / 2;
                    bulletY = tank.y + tank.height * (0.5 + offsetMultiplier / 2) - currentBulletHeight / 2;
                    break;
            }
            return { x: bulletX, y: bulletY, width: currentBulletWidth, height: currentBulletHeight, dx: dx, dy: dy, owner: owner };
        }
        function moveBullets() { /* ... (sem mudan√ßas) ... */
             if (gameState !== 'playing') return; const currentBulletSpeedPlayer = BULLET_SPEED_PLAYER; const currentBulletSpeedEnemy = BULLET_SPEED_ENEMY; for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; b.x += b.dx; b.y += b.dy; if (b.x < -b.width || b.x > canvas.width || b.y < -b.height || b.y > canvas.height) bullets.splice(i, 1); } for (let i = enemyBullets.length - 1; i >= 0; i--) { const b = enemyBullets[i]; b.x += b.dx; b.y += b.dy; if (b.x < -b.width || b.x > canvas.width || b.y < -b.height || b.y > canvas.height) enemyBullets.splice(i, 1); }
        }

        // --- Fun√ß√µes de Colis√£o e Utilit√°rios ---
        function checkCollisions() { // Atualizado para respeitar limite de spawn
             if (gameState !== 'playing') return;
             // Balas do jogador vs Inimigos
             for (let i = bullets.length - 1; i >= 0; i--) { const bullet = bullets[i]; for (let j = enemies.length - 1; j >= 0; j--) { const enemy = enemies[j]; if (isColliding(bullet, enemy)) { explosionSound.play(); bullets.splice(i, 1); enemies.splice(j, 1); updateScore(POINTS_PER_KILL); killsThisPhase++; updateInfoDisplays();
                 if (killsThisPhase >= killsNeededThisPhase) {
                     phaseCompleteSequence();
                 } else if (enemiesSpawnedThisPhase < killsNeededThisPhase) { // S√≥ spawna se o total da fase n√£o foi atingido
                     if (enemies.length < MAX_ENEMIES_ON_SCREEN) { // E se houver espa√ßo na tela
                         setTimeout(createEnemy, 750);
                     }
                 }
                 break; } } if (!bullets[i]) break; }
             // Balas inimigas vs Jogador
             if (playerTank && !playerTank.invulnerable) { for (let i = enemyBullets.length - 1; i >= 0; i--) { const bullet = enemyBullets[i]; if (isColliding(bullet, playerTank)) { enemyBullets.splice(i, 1); playerHit(); break; } } }
        }
        function isColliding(rect1, rect2) { /* ... (sem mudan√ßas) ... */
             if (!rect1 || !rect2) return false; return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
        function isOverlapping(x, y, width, height, objects) { /* ... (sem mudan√ßas) ... */
             const checkRect = { x, y, width, height }; for (const obj of objects) { if (!obj) continue; if (isColliding(checkRect, obj)) return true; } return false;
        }

        // --- Fun√ß√µes de UI e Estado ---
        function updateInfoDisplays() { /* ... (sem mudan√ßas) ... */
             scoreDisplay.textContent = score; destroyedCountDisplay.textContent = `${killsThisPhase}/${killsNeededThisPhase}`; livesCountDisplay.textContent = `${playerLives}/${MAX_LIVES}`;
        }
        function updateHpBar() { /* ... (sem mudan√ßas) ... */
             const hpPercentage = Math.max(0, (playerHP / MAX_HP) * 100); hpBarInner.style.width = hpPercentage + '%'; if (hpPercentage > 66) hpBarInner.style.backgroundColor = '#4CAF50'; else if (hpPercentage > 33) hpBarInner.style.backgroundColor = '#FFC107'; else hpBarInner.style.backgroundColor = '#F44336';
        }
        function showStartScreen() { // Atualizado para esconder toggle
             gameState = 'start'; startScreen.style.display = 'flex'; gameContainer.style.display = 'none'; gameOverMessage.style.display = 'none'; winMessage.style.display = 'none'; pauseMenu.style.display = 'none'; mobileControls.style.display = 'none'; /* Esconde toggle btn aqui tamb√©m */ if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        }
        function restartGame() { // Reseta contadores de spawn
            gameState = 'playing'; score = 0; currentPhase = 1; killsThisPhase = 0;
            killsNeededThisPhase = KILLS_PER_PHASE_BASE; // Define meta inicial
            enemiesSpawnedThisPhase = 0; // Reseta contador de spawn
            bullets.length = 0; enemies.length = 0; enemyBullets.length = 0;
            resizeCanvas(); playerTank = createPlayer(false);
            // Spawna inimigos iniciais (at√© o limite da tela E o limite da fase)
            for(let i = 0; i < MAX_ENEMIES_ON_SCREEN && enemiesSpawnedThisPhase < killsNeededThisPhase; i++) {
                 // A fun√ß√£o createEnemy agora incrementa enemiesSpawnedThisPhase
                 setTimeout(createEnemy, i * 200);
            }
            gameOverMessage.style.display = 'none'; winMessage.style.display = 'none'; pauseMenu.style.display = 'none';
            if (isTouchDevice) {
                 mobileControls.style.display = 'flex'; // Mostra container
                 // Mostra bot√µes dentro de action-buttons
                 pauseButtonMobile.style.display = 'flex';
                 // toggleControlsButton removido
            } else { mobileControls.style.display = 'none'; /* toggleControlsButton removido */ }
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }
        function startGame() { startScreen.style.display = 'none'; gameContainer.style.display = 'flex'; restartGame(); } // mobileControlsVisible removido
        function nextPhase() { // Atualiza contadores de spawn
             currentPhase++; killsThisPhase = 0;
             killsNeededThisPhase += 5; // Aumenta meta de kills/total de inimigos
             enemiesSpawnedThisPhase = 0; // Reseta contador de spawn para nova fase
             bullets.length = 0; enemies.length = 0; enemyBullets.length = 0;
             if(playerTank) { playerTank.invulnerable = true; playerTank.invulnerabilityEndTime = Date.now() + INVULNERABILITY_DURATION_SPAWN; playerTank.visible = true; playerHP = MAX_HP; updateHpBar(); } else { playerTank = createPlayer(true); }
             // Spawna inimigos iniciais da nova fase
             for(let i = 0; i < MAX_ENEMIES_ON_SCREEN && enemiesSpawnedThisPhase < killsNeededThisPhase; i++) {
                  setTimeout(createEnemy, i * 200);
             }
             updateInfoDisplays(); winMessage.style.display = 'none'; gameState = 'playing'; if (!animationFrameId) { gameLoop(); }
        }
        function gameOverSequence() { /* ... (sem mudan√ßas) ... */
             gameState = 'gameOver'; gameOverSound.play(); playerTank = null; gameOverMessage.style.display = 'block'; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } draw();
        }
        function phaseCompleteSequence() { /* ... (sem mudan√ßas) ... */
             gameState = 'phaseComplete'; phaseCompleteSound.play(); winMessage.style.display = 'block'; enemyBullets.length = 0; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } draw();
        }
        function updateScore(points) { /* ... (sem mudan√ßas) ... */
             score += points; score = Math.max(0, score); updateInfoDisplays();
        }

        // --- Fun√ß√£o de Pause ---
        function togglePause() { /* ... (sem mudan√ßas) ... */
             if (gameState === 'playing') { gameState = 'paused'; pauseMenu.style.display = 'flex'; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } draw(); } else if (gameState === 'paused') { gameState = 'playing'; pauseMenu.style.display = 'none'; if (!animationFrameId) { gameLoop(); } }
        }
        // --- Fun√ß√£o Toggle Controles Mobile Removida ---


        // --- Fun√ß√µes de Desenho ---
        function drawGrassBackground() { /* ... (removido) ... */ } // N√£o √© mais necess√°rio
        function draw() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             // Fundo √© desenhado via CSS
             if (playerTank && playerTank.visible) { drawTank(playerTank); }
             enemies.forEach(drawTank);
             ctx.fillStyle = '#FFFF00'; bullets.forEach(b => { ctx.fillRect(b.x, b.y, b.width, b.height); });
             ctx.fillStyle = '#FF6347'; enemyBullets.forEach(b => { ctx.fillRect(b.x, b.y, b.width, b.height); });
        }
        function drawTank(tank) { // Corrigido para preservar aspect ratio da imagem
             const x = tank.x, y = tank.y, w = tank.width, h = tank.height;

             if (tank === playerTank) { // Desenha imagem para o jogador
                 const img = playerImages[tank.direction];
                 if (img && img.complete && img.naturalHeight !== 0) {
                     ctx.save();
                     if (tank.invulnerable && !tank.visible) { ctx.globalAlpha = 0.4; }
                     else { ctx.globalAlpha = 1.0; }

                     // Preserva aspect ratio
                     const imgRatio = img.naturalWidth / img.naturalHeight;
                     let drawW = w;
                     let drawH = h;
                     // Calcula dimens√µes para caber sem distorcer
                     if (w / h > imgRatio) { // √Årea do tanque √© mais larga que a imagem
                         drawW = h * imgRatio;
                     } else { // √Årea do tanque √© mais alta (ou quadrada igual)
                         drawH = w / imgRatio;
                     }
                     // Centraliza a imagem dentro da √°rea do tanque (w x h)
                     const drawX = x + (w - drawW) / 2;
                     const drawY = y + (h - drawH) / 2;

                     ctx.drawImage(img, drawX, drawY, drawW, drawH);
                     ctx.restore();
                 } else { // Fallback
                     ctx.fillStyle = "#FFF"; ctx.fillRect(x, y, w, h);
                 }
             } else { // Desenha ret√¢ngulos rotacionados para inimigos
                 const cx = x + w / 2, cy = y + h / 2; ctx.save(); ctx.translate(cx, cy); let angle = 0; switch (tank.direction) { case 'up': angle = 0; break; case 'up-right': angle = Math.PI / 4; break; case 'right': angle = Math.PI / 2; break; case 'down-right': angle = 3 * Math.PI / 4; break; case 'down': angle = Math.PI; break; case 'down-left': angle = -3 * Math.PI / 4; break; case 'left': angle = -Math.PI / 2; break; case 'up-left': angle = -Math.PI / 4; break; } ctx.rotate(angle); const trackW = w * 0.2, bodyW = w - 2 * trackW, bodyH = h * 0.8; const gunL = h * 0.5, gunW = w * 0.15; let bodyC = tank.color, trackC = tank.trackColor; ctx.fillStyle = trackC; ctx.fillRect(-w / 2, -h / 2, trackW, h); ctx.fillRect(w / 2 - trackW, -h / 2, trackW, h); ctx.fillStyle = bodyC; ctx.fillRect(-bodyW / 2, -bodyH / 2, bodyW, bodyH); ctx.fillStyle = bodyC; ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; const turretSize = bodyW * 0.6; ctx.fillRect(-turretSize / 2, -turretSize / 2, turretSize, turretSize); ctx.strokeRect(-turretSize / 2, -turretSize / 2, turretSize, turretSize); ctx.fillStyle = tank.gunColor; ctx.fillRect(-gunW / 2, -h / 2 - gunL + bodyH/2, gunW, gunL); ctx.restore();
             }
        }


        // --- Loop Principal ---
        function gameLoop() { /* ... (sem mudan√ßas) ... */
             if (gameState === 'playing') { updatePlayerInvulnerability(); updatePlayerDirectionAndMovement(); movePlayer(); moveEnemies(); moveBullets(); checkCollisions(); } if (gameState !== 'start') { draw(); } if (gameState === 'playing') { animationFrameId = requestAnimationFrame(gameLoop); } else { animationFrameId = null; }
        }

        // --- Detec√ß√£o de Touch ---
        function detectTouch() { /* ... (sem mudan√ßas) ... */
             try { document.createEvent("TouchEvent"); isTouchDevice = true; } catch (e) { isTouchDevice = false; }
        }

        // --- Redimensionamento ---
        function resizeCanvas() { /* ... (sem mudan√ßas) ... */
            const container = gameContainer; const aspectRatio = 9 / 16; /* Propor√ß√£o Retrato */ let newWidth = container.clientWidth; let newHeight = container.clientHeight; if (newWidth / newHeight > aspectRatio) { newWidth = newHeight * aspectRatio; } else { newHeight = newWidth / aspectRatio; } canvas.style.width = `${newWidth}px`; canvas.style.height = `${newHeight}px`; if (gameState !== 'start') { draw(); }
        }

        // --- Controles e Event Listeners ---
        function setupEventListeners() {
            startButton.addEventListener('click', () => {
                if (imagesLoaded === totalImages) { startGame(); }
                else { console.log("Aguardando imagens..."); /* Ou mostra mensagem na UI */ }
            });
            restartButton.addEventListener('click', restartGame);
            restartPauseButton.addEventListener('click', restartGame);
            nextPhaseButton.addEventListener('click', nextPhase);
            resumeButton.addEventListener('click', togglePause);
            exitPauseButton.addEventListener('click', showStartScreen);
            // Listener do toggleControlsButton removido

            // Teclado
            document.addEventListener("keydown", function(e) { /* ... (sem mudan√ßas) ... */
                if (e.key === "Escape") { togglePause(); return; } if (!playerTank || gameState !== 'playing') return; if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "w", "a", "s", "d", "W", "A", "S", "D"].includes(e.key)) e.preventDefault(); if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") keysPressed.up = true; if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") keysPressed.down = true; if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keysPressed.left = true; if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keysPressed.right = true; if (e.key === " ") { shootPlayerBullet(); }
             });
            document.addEventListener("keyup", function(e) { /* ... (sem mudan√ßas) ... */
                 if (!playerTank) return; if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") keysPressed.up = false; if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") keysPressed.down = false; if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keysPressed.left = false; if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keysPressed.right = false; if (!keysPressed.up && !keysPressed.down && !keysPressed.left && !keysPressed.right) { if(playerTank){ playerTank.dx = 0; playerTank.dy = 0;} }
            });

            // Touch (Anal√≥gico Virtual - L√≥gica de Mapeamento Corrigida)
            analogStickArea.addEventListener('touchstart', (e) => { /* ... (sem mudan√ßas) ... */
                if (!playerTank || gameState !== 'playing') return; e.preventDefault(); analogActive = true; const rect = analogStickArea.getBoundingClientRect(); analogCenterX = rect.left + rect.width / 2; analogCenterY = rect.top + rect.height / 2; analogRadius = rect.width / 2; const touch = e.touches[0]; analogStartX = touch.clientX; analogStartY = touch.clientY;
            });
            analogStickArea.addEventListener('touchmove', (e) => { // L√≥gica de √¢ngulo/dire√ß√£o corrigida
                if (!analogActive || !playerTank || gameState !== 'playing') return; e.preventDefault(); const touch = e.touches[0];
                let deltaX = touch.clientX - analogCenterX; let deltaY = touch.clientY - analogCenterY; const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxHandleDistance = analogRadius * 0.6; let handleDeltaX = deltaX; let handleDeltaY = deltaY; if (distance > maxHandleDistance) { handleDeltaX = (deltaX / distance) * maxHandleDistance; handleDeltaY = (deltaY / distance) * maxHandleDistance; } analogHandle.style.transform = `translate(-50%, -50%) translate(${handleDeltaX}px, ${handleDeltaY}px)`;
                let targetDx = 0; let targetDy = 0; let direction = playerTank.direction;
                if (distance > analogRadius * ANALOG_DEAD_ZONE) {
                    const angle = Math.atan2(deltaY, deltaX); const slice = Math.PI / 4;
                    if (angle > -slice / 2 && angle <= slice / 2) { direction = 'right'; targetDx = 1; targetDy = 0; }
                    else if (angle > slice / 2 && angle <= 3 * slice / 2) { direction = 'down-right'; targetDx = 1; targetDy = 1; }
                    else if (angle > 3 * slice / 2 && angle <= 5 * slice / 2) { direction = 'down'; targetDx = 0; targetDy = 1; }
                    else if (angle > 5 * slice / 2 && angle <= 7 * slice / 2) { direction = 'down-left'; targetDx = -1; targetDy = 1; }
                    else if (angle > 7 * slice / 2 || angle <= -7 * slice / 2) { direction = 'left'; targetDx = -1; targetDy = 0; } // Ajuste para √¢ngulo negativo
                    else if (angle > -7 * slice / 2 && angle <= -5 * slice / 2) { direction = 'up-left'; targetDx = -1; targetDy = -1; }
                    else if (angle > -5 * slice / 2 && angle <= -3 * slice / 2) { direction = 'up'; targetDx = 0; targetDy = -1; }
                    else if (angle > -3 * slice / 2 && angle <= -slice / 2) { direction = 'up-right'; targetDx = 1; targetDy = -1; }
                }
                playerTank.dx = targetDx; playerTank.dy = targetDy; playerTank.direction = direction;
            });
            const analogStop = (e) => { /* ... (sem mudan√ßas) ... */
                if (!analogActive) return; e.preventDefault(); analogActive = false; if (playerTank) { playerTank.dx = 0; playerTank.dy = 0; } analogHandle.style.transform = `translate(-50%, -50%)`;
            };
            analogStickArea.addEventListener('touchend', analogStop);
            analogStickArea.addEventListener('touchcancel', analogStop);

            shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); shootPlayerBullet(); });
            pauseButtonMobile.addEventListener('click', (e) => { e.preventDefault(); togglePause(); });

            // Listener para redimensionar
            window.addEventListener('resize', resizeCanvas);
        }

        // --- Iniciar ---
        window.onload = () => {
            detectTouch();
            setupEventListeners();
            // Pr√©-carrega as imagens ANTES de mostrar a tela inicial ou iniciar o jogo
            preloadImages(() => {
                // Este callback ser√° chamado quando todas as imagens carregarem
                showStartScreen(); // Mostra a tela inicial ap√≥s carregar
                resizeCanvas(); // Chama resize inicial
            });
        };

    </script>

</body>
</html>
